<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Endless Train - Bleak Russian Tundra</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: monospace; color: #dcdcdc; background: #0a0a1a; }
    canvas { display: block; position: fixed; top: 0; left: 0; z-index: 1; }
    .overlay { position: fixed; z-index: 3; pointer-events: none; }
    .train { bottom: 20%; left: -40%; white-space: nowrap; font-size: 2rem; color: #444; animation: moveTrain 25s linear infinite; z-index: 4; }
    @keyframes moveTrain { 0% { left: -40%; } 100% { left: 110%; } }
    .station { bottom: 5%; width: 100%; text-align: center; font-size: 1.2rem; opacity: 0.8; z-index: 4; }
    .clock { top: 10px; right: 10px; font-size: 1.2rem; z-index: 4; }
    .weather { top: 40px; right: 10px; font-size: 1.2rem; z-index: 4; }
    #ui { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; z-index: 5; pointer-events: auto; }
    #ui button { margin: 5px; padding: 5px; background: #333; color: #dcdcdc; border: none; border-radius: 3px; cursor: pointer; }
    input[type=range] { width: 100px; margin: 5px; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div class="train overlay">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â• ðŸš‚â•£â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</div>
  <div id="station" class="station overlay"></div>
  <div id="clock" class="clock overlay"></div>
  <div id="weather" class="weather overlay">Moscow: -5Â°C, Snow</div> 
  
  <div id="ui">
    <button onclick="toggleUI()">Hide UI</button>
    <br>Speed: <input type="range" id="speedSlider" min="0.1" max="2" step="0.1" value="0.3" onchange="updateSpeed(this.value)">
    <br>Snow: <input type="range" id="snowSlider" min="0" max="1" step="0.1" value="0.8" onchange="updateSnow(this.value)">
    <br>Fog: <input type="range" id="fogSlider" min="0.5" max="2" step="0.1" value="1" onchange="updateFog(this.value)">
    <br>Bleakness: <input type="range" id="bleakSlider" min="0" max="1" step="0.1" value="0.7" onchange="updateBleak(this.value)">
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Corrected Simplex Noise class (2D implementation)
    class SimplexNoise {
      constructor() {
        this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                      [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                      [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
        this.p = [];
        for (let i = 0; i < 256; i++) {
          this.p[i] = i;
        }
        // Shuffle p array (Fisher-Yates)
        for (let i = 255; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
        }
        this.perm = [];
        for (let i = 0; i < 512; i++) {
          this.perm[i] = this.p[i & 255];
        }
      }
      dot(g, x, y) {
        return g[0] * x + g[1] * y;
      }
      noise(xin, yin) {
        const F2 = 0.5 * (Math.sqrt(3) - 1);
        const G2 = (3 - Math.sqrt(3)) / 6;
        let n0, n1, n2;
        const s = (xin + yin) * F2;
        const i = Math.floor(xin + s);
        const j = Math.floor(yin + s);
        const t = (i + j) * G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = xin - X0;
        const y0 = yin - Y0;
        let i1, j1;
        if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1 + 2 * G2;
        const y2 = y0 - 1 + 2 * G2;
        const ii = i & 255;
        const jj = j & 255;
        const gi0 = this.perm[ii + this.perm[jj]] % 12;
        const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
        const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
        let t0 = 0.5 - x0 * x0 - y0 * y0;
        if (t0 < 0) n0 = 0;
        else { t0 *= t0; n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); }
        let t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 < 0) n1 = 0;
        else { t1 *= t1; n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1); }
        let t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 < 0) n2 = 0;
        else { t2 *= t2; n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2); }
        return 70 * (n0 + n1 + n2);
      }
    }
    const simplex = new SimplexNoise();

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a1a);
    scene.fog = new THREE.Fog(0x0a0a1a, 100, 600);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 60, 120);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const hemi = new THREE.HemisphereLight(0xeeeeff, 0x444466, 0.6);
    scene.add(hemi);

    const moon = new THREE.DirectionalLight(0xffffff, 1.0);
    moon.position.set(100, 200, 100);
    moon.castShadow = true;
    moon.shadow.mapSize.width = 1024;
    moon.shadow.mapSize.height = 1024;
    moon.shadow.camera.near = 0.5;
    moon.shadow.camera.far = 500;
    scene.add(moon);

    // Stars
    const starCount = 2000;
    const starGeo = new THREE.BufferGeometry();
    const starPositions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      const theta = Math.random() * 2 * Math.PI;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 1000;
      starPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
      starPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta) + 100;
      starPositions[i * 3 + 2] = r * Math.cos(phi);
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    // Terrain Setup (foreground tundra)
    const SIZE = 400;
    const SEG = 100;
    const terrainMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9, metalness: 0.0 });
    terrainMat.side = THREE.DoubleSide;

    function updateTerrainGeo(geo, baseZ) {
      const pos = geo.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const localY = pos.getY(i);
        const worldZ = baseZ + localY;
        const z = simplex.noise(x * 0.02, worldZ * 0.02) * 20;
        pos.setZ(i, z);
      }
      pos.needsUpdate = true;
      geo.computeVertexNormals();
    }

    const terrainGeo1 = new THREE.PlaneGeometry(SIZE, SIZE, SEG, SEG);
    updateTerrainGeo(terrainGeo1, 0);
    terrainGeo1.rotateX(-Math.PI / 2);
    const terrain1 = new THREE.Mesh(terrainGeo1, terrainMat);
    terrain1.receiveShadow = true;
    terrain1.position.z = SIZE / 2;
    scene.add(terrain1);

    const terrainGeo2 = new THREE.PlaneGeometry(SIZE, SIZE, SEG, SEG);
    updateTerrainGeo(terrainGeo2, -SIZE);
    terrainGeo2.rotateX(-Math.PI / 2);
    const terrain2 = new THREE.Mesh(terrainGeo2, terrainMat);
    terrain2.receiveShadow = true;
    terrain2.position.z = -SIZE / 2;
    scene.add(terrain2);

    // Distant Mountains (background scenery, lower frequency noise for larger hills)
    const mountainMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 1.0, metalness: 0.0 });
    function createMountain(baseZ) {
      const geo = new THREE.PlaneGeometry(SIZE * 2, SIZE * 2, SEG / 2, SEG / 2);
      const pos = geo.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const localY = pos.getY(i);
        const worldZ = baseZ + localY;
        const z = simplex.noise(x * 0.005, worldZ * 0.005) * 100; // Larger, smoother hills
        pos.setZ(i, z);
      }
      pos.needsUpdate = true;
      geo.computeVertexNormals();
      geo.rotateX(-Math.PI / 2);
      const mesh = new THREE.Mesh(geo, mountainMat);
      mesh.position.set(0, -20, baseZ); // Slightly lower and farther
      mesh.receiveShadow = true;
      return mesh;
    }
    let mountain1 = createMountain(0);
    let mountain2 = createMountain(-SIZE * 2);
    scene.add(mountain1, mountain2);

    // Trees (enhanced modeling: multi-tier foliage with random scale/rotation)
    const treeGroup1 = new THREE.Group();
    const treeGroup2 = new THREE.Group();
    scene.add(treeGroup1, treeGroup2);

    function makeTree(x, z) {
      const tree = new THREE.Group();
      const trunkGeo = new THREE.CylinderGeometry(0.2 + Math.random() * 0.1, 0.3 + Math.random() * 0.1, 4 + Math.random() * 2, 8);
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a2c2c });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.castShadow = true;
      trunk.receiveShadow = true;
      trunk.position.y = trunkGeo.parameters.height / 2;
      tree.add(trunk);

      // Multi-tier foliage
      for (let tier = 0; tier < 3; tier++) {
        const radius = 1.5 - tier * 0.3 + Math.random() * 0.2;
        const height = 3 - tier * 0.5 + Math.random() * 0.5;
        const foliageGeo = new THREE.ConeGeometry(radius, height, 8);
        const foliageMat = new THREE.MeshStandardMaterial({ color: 0x385c38 });
        const foliage = new THREE.Mesh(foliageGeo, foliageMat);
        foliage.castShadow = true;
        foliage.receiveShadow = true;
        foliage.position.y = trunkGeo.parameters.height + tier * (height / 2 - 0.5) + Math.random() * 0.5;
        foliage.rotation.y = Math.random() * Math.PI * 2; // Random rotation for variety
        tree.add(foliage);
      }

      const y = getHeightAt(x, z) + 0.1;
      tree.position.set(x, y, z);
      tree.scale.set(1 + Math.random() * 0.2, 1 + Math.random() * 0.3, 1 + Math.random() * 0.2); // Slight scale variation

      return tree;
    }

    function getHeightAt(x, z) {
      return simplex.noise(x * 0.02, z * 0.02) * 20;
    }

    function generateTrees(group, baseZ, treeCount = 200) {
      group.children.length = 0;
      for (let i = 0; i < treeCount; i++) {
        const x = (Math.random() - 0.5) * SIZE;
        const localZ = (Math.random() - 0.5) * SIZE;
        const worldZ = baseZ + localZ;
        group.add(makeTree(x, worldZ));
      }
    }

    generateTrees(treeGroup1, 0);
    generateTrees(treeGroup2, -SIZE);

    // Train Tracks (3D modeled rails and sleepers, procedural segments)
    const trackGroup1 = new THREE.Group();
    const trackGroup2 = new THREE.Group();
    scene.add(trackGroup1, trackGroup2);

    function makeTrackSegment(baseZ, length = 50) {
      const track = new THREE.Group();
      const railMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.4 });
      const sleeperMat = new THREE.MeshStandardMaterial({ color: 0x3a2518, roughness: 0.9 });

      // Two rails
      const rail1 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, length, 8), railMat);
      rail1.rotation.x = Math.PI / 2;
      rail1.position.set(-0.75, 0.1, baseZ);
      track.add(rail1);

      const rail2 = rail1.clone();
      rail2.position.x = 0.75;
      track.add(rail2);

      // Sleepers (cross bars)
      for (let i = 0; i < length / 2; i++) {
        const sleeper = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 0.2), sleeperMat);
        sleeper.position.set(0, 0.05, baseZ - i * 2);
        track.add(sleeper);
      }

      return track;
    }

    function generateTracks(group, baseZ) {
      group.children.length = 0;
      group.add(makeTrackSegment(baseZ, SIZE));
    }

    generateTracks(trackGroup1, SIZE / 2);
    generateTracks(trackGroup2, -SIZE / 2);

    // Utility Poles (scenery: sparse poles along tracks)
    function makePole(x, z) {
      const pole = new THREE.Group();
      const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 10, 6);
      const poleMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
      const poleMesh = new THREE.Mesh(poleGeo, poleMat);
      poleMesh.position.y = 5;
      pole.add(poleMesh);

      // Crossbar
      const crossGeo = new THREE.BoxGeometry(2, 0.05, 0.05);
      const cross = new THREE.Mesh(crossGeo, poleMat);
      cross.position.y = 9;
      pole.add(cross);

      const y = getHeightAt(x, z) + 0.1;
      pole.position.set(x, y, z);

      return pole;
    }

    function generatePoles(group, baseZ, count = 20) {
      for (let i = 0; i < count; i++) {
        const localZ = baseZ - i * (SIZE / count);
        group.add(makePole(2 + Math.random() * 2, localZ)); // Slightly offset from track
      }
    }

    generatePoles(trackGroup1, SIZE / 2);
    generatePoles(trackGroup2, -SIZE / 2);

    // Snow Particles
    const snowCount = 5000;
    const snowGeo = new THREE.BufferGeometry();
    const snowPositions = new Float32Array(snowCount * 3);
    const snowVelocities = new Float32Array(snowCount);
    for (let i = 0; i < snowCount; i++) {
      snowPositions[i * 3] = (Math.random() - 0.5) * 500;
      snowPositions[i * 3 + 1] = Math.random() * 200;
      snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 500;
      snowVelocities[i] = 0.1 + Math.random() * 0.05;
    }
    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
    const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8 });
    const snow = new THREE.Points(snowGeo, snowMat);
    scene.add(snow);

    // Camera movement variables
    let speed = 0.3; // Slower for relaxed ride
    let offsetZ = 0;
    let time = 0;

    function animate() {
      requestAnimationFrame(animate);

      time += 0.01;
      offsetZ += speed;
      camera.position.z = 120 - offsetZ;

      // Subtle curve to track (procedural x offset)
      const curve = simplex.noise(0, (camera.position.z / 100) * 0.05) * 10; // Gentle winding
      camera.position.x = curve;

      // Follow terrain height
      const camWorldZ = camera.position.z;
      camera.position.y = getHeightAt(camera.position.x, camWorldZ) + 60 + Math.sin(time) * 0.5; // Gentle bob

      // Look forward
      const lookZ = camWorldZ - 100;
      camera.lookAt(curve, getHeightAt(curve, lookZ) + 40, lookZ);

      // Shift terrains, trees, tracks, mountains
      const center1 = terrain1.position.z;
      const center2 = terrain2.position.z;
      if (camera.position.z < center1 - SIZE) {
        terrain1.position.z = center2 - SIZE;
        updateTerrainGeo(terrainGeo1, terrain1.position.z);
        treeGroup1.position.z = terrain1.position.z;
        generateTrees(treeGroup1, terrain1.position.z);
        trackGroup1.position.z = terrain1.position.z;
        generateTracks(trackGroup1, terrain1.position.z);
        generatePoles(trackGroup1, terrain1.position.z);
        mountain1.position.z = terrain1.position.z - SIZE * 2; // Farther back
      } else if (camera.position.z < center2 - SIZE) {
        terrain2.position.z = center1 - SIZE;
        updateTerrainGeo(terrainGeo2, terrain2.position.z);
        treeGroup2.position.z = terrain2.position.z;
        generateTrees(treeGroup2, terrain2.position.z);
        trackGroup2.position.z = terrain2.position.z;
        generateTracks(trackGroup2, terrain2.position.z);
        generatePoles(trackGroup2, terrain2.position.z);
        mountain2.position.z = terrain2.position.z - SIZE * 2;
      }

      // Update snow with wind
      snow.position.z = camera.position.z;
      const pos = snow.geometry.attributes.position.array;
      for (let i = 0; i < snowCount; i++) {
        pos[i * 3 + 1] -= snowVelocities[i];
        pos[i * 3] += Math.sin(time * 0.5) * 0.05; // Lateral wind drift
        if (pos[i * 3 + 1] < 0) {
          pos[i * 3 + 1] = 200;
          pos[i * 3] = (Math.random() - 0.5) * 500;
          pos[i * 3 + 2] = (Math.random() - 0.5) * 500;
        }
      }
      snow.geometry.attributes.position.needsUpdate = true;

      // Star twinkle
      starMat.opacity = 0.8 + 0.2 * Math.sin(time * 2);

      renderer.render(scene, camera);
    }

    animate();

    // Handle resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Stations, clock, weather (as before)
    const stations = [
      "ÐÐ°Ð´ÐµÐ¶Ð´Ð° (Nadezhda)",
      "Ð—Ð°Ð±Ð²ÐµÐ½Ð¸Ðµ (Oblivion)",
      "Ð“Ð¾Ñ€ÑŒÐºÐ¸Ð¹ Ð£Ñ‚Ñ€Ð¾ (Bitter Morning)",
      "Ð¥Ð¾Ð»Ð¾Ð´Ð½Ð°Ñ Ð ÐµÐºÐ° (Cold River)",
      "Ð‘ÐµÐ·Ð¼Ð¾Ð»Ð²Ð¸Ðµ (Silence)",
      "Ð¢ÐµÐ½Ð¸ Ð—Ð°Ð²Ð¾Ð´Ð° (Shadows of the Factory)",
      "Ð’ÐµÑ‡Ð½Ð°Ñ Ð—Ð¸Ð¼Ð° (Eternal Winter)",
      "Ð¡ÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð¡Ð²ÐµÑ‚ (Northern Light)",
      "ÐŸÐµÐ¿ÐµÐ» (Ashes)",
      "ÐŸÐ¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ð“Ð¾Ñ€Ð¾Ð´ (Last City)"
    ];

    const stationDiv = document.getElementById('station');
    function updateStation() {
      const name = stations[Math.floor(Math.random() * stations.length)];
      stationDiv.textContent = name;
    }
    updateStation();
    setInterval(updateStation, 30000);
    document.body.addEventListener('click', updateStation);

    const clockDiv = document.getElementById('clock');
    function updateClock() {
      const now = new Date();
      clockDiv.textContent = now.toLocaleTimeString();
    }
    updateClock();
    setInterval(updateClock, 1000);

    // Weather (mocked; add API key for real)
    const weatherDiv = document.getElementById('weather');
    // const apiKey = 'YOUR_API_KEY_HERE';
    // fetch(`https://api.openweathermap.org/data/2.5/weather?q=Moscow&appid=${apiKey}&units=metric`)...

    // UI controls
    function toggleUI() { document.getElementById('ui').classList.toggle('hidden'); }
    function updateSpeed(val) { speed = parseFloat(val); }
    function updateSnow(val) { snowMat.opacity = parseFloat(val); snow.visible = val > 0; }
    function updateFog(val) { scene.fog.far = 600 / parseFloat(val); }
    function updateBleak(val) { /* Regenerate trees/terrain on change if needed */ }

    // Make functions globally available
    window.toggleUI = toggleUI;
    window.updateSpeed = updateSpeed;
    window.updateSnow = updateSnow;
    window.updateFog = updateFog;
    window.updateBleak = updateBleak;
  </script>
</body>
</html>